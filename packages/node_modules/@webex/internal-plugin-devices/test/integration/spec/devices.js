import {constants} from '@webex/internal-plugin-devices';
import chai from 'chai';
import chaiAsPromised from 'chai-as-promised';
import sinon from 'sinon';
import testUsers from '@webex/test-helper-test-users';
import WebexCore from '@webex/webex-core';

const {assert} = chai;
const {DEVICES_EVENT_REGISTRATION_SUCCESS} = constants;

chai.use(chaiAsPromised);
sinon.assert.expose(chai.assert, {prefix: ''});

describe('plugin-devices', () => {
  describe('Devices', () => {
    let devices;
    let user;
    let webex;

    before('create users', () => testUsers.create({count: 1})
      .then(([createdUser]) => {
        user = createdUser;
      }));

    beforeEach('create the webex instance', () => {
      webex = new WebexCore({
        credentials: user.token
      });

      devices = webex.internal.devices;
    });

    // This will be implemented in the same pull request that `unregister()` is
    // implemented.
    afterEach('attempt to unregister the device', () => {});

    after('remove users', () => testUsers.remove([user]));

    describe('events', () => {
      describe('when a meeting is started', () => {
        beforeEach('setup sinon', () => {
          devices.resetLogoutTimer = sinon.spy();
          webex.trigger('meeting started');
        });

        it('should set \'isInMeeting\' to \'true\'', () => {
          assert.isTrue(devices.isInMeeting);
        });

        it('should call \'resetLogoutTimer()\'', () => {
          assert.called(devices.resetLogoutTimer);
        });
      });

      describe('when a meeting has ended', () => {
        beforeEach('setup sinon', () => {
          devices.resetLogoutTimer = sinon.spy();
          devices.isInMeeting = false;
          webex.trigger('meeting ended');
        });

        it('should set \'isInMeeting\' to \'false\'', () => {
          assert.isFalse(devices.isInMeeting);
        });

        it('should call \'resetLogoutTimer()\'', () => {
          assert.called(devices.resetLogoutTimer);
        });
      });
    });

    describe('#canRegister()', () => {
      describe('when wait is truthy', () => {
        let wait;

        beforeEach('set wait', () => {
          wait = true;
        });

        describe('when the `wdm` service is available', () => {
          let services;

          beforeEach('destructure services plugin and get catalog', () => {
            services = webex.internal.services;

            return services.waitForCatalog('postauth');
          });

          it('should return a resolved promise', () => {
            assert.isDefined(services.get('wdm'));
            assert.isFulfilled(devices.canRegister(wait));
          });
        });

        describe('when the service catalog is not ready', () => {
          let services;

          beforeEach('setup catalog to be not ready', () => {
            services = webex.internal.services;

            services.updateServices();
          });

          describe('when the \'wdm\' service does exist after wait', () => {
            it('should return a resolved promise', () => {
              /* eslint-disable-next-line no-underscore-dangle */
              assert.isTrue(services._getCatalog().status.postauth.collecting);
              assert.isFulfilled(devices.canRegister(wait));
            });
          });

          describe('when the \'wdm\' service does not exist after wait', () => {
            beforeEach('remove wdm service', () => {
              services.get = sinon.stub().returns(undefined);
              services.waitForCatalog = sinon.stub().resolves();
            });

            it('should return a rejected promise', () => {
              /* eslint-disable-next-line no-underscore-dangle */
              assert.isTrue(services._getCatalog().status.postauth.collecting);
              assert.isRejected(devices.canRegister(wait));
            });
          });
        });

        describe('when the `wdm` service is not available', () => {
          let catalog;
          let services;

          beforeEach('remove wdm service', () => {
            services = webex.internal.services;
            /* eslint-disable-next-line no-underscore-dangle */
            catalog = services._getCatalog();

            catalog.serviceGroups.postauth = [];
          });

          it('should return a rejected promise', () => {
            assert.isUndefined(services.get('wdm'));
            assert.isRejected(devices.canRegister(wait));
          });
        });
      });

      describe('when wait is falsy', () => {
        let wait;

        beforeEach('set wait', () => {
          wait = false;
        });

        describe('when the `wdm` service is available', () => {
          let services;

          beforeEach('destructure services plugin', () => {
            services = webex.internal.services;

            return services.updateServices();
          });

          it('should return a resolved promise', () => {
            assert.isDefined(services.get('wdm'));
            assert.isFulfilled(devices.canRegister(wait));
          });
        });

        describe('when the service catalog is not ready', () => {
          let catalog;
          let services;

          beforeEach('setup catalog to be not ready', () => {
            services = webex.internal.services;
            /* eslint-disable-next-line no-underscore-dangle */
            catalog = services._getCatalog();
            catalog.serviceGroups.postauth = [];

            services.updateServices();
          });

          it('should return a rejected promise', () => {
            /* eslint-disable-next-line no-underscore-dangle */
            assert.isTrue(services._getCatalog().status.postauth.collecting);
            assert.isRejected(devices.canRegister(wait));
          });
        });

        describe('when the `wdm` service is not available', () => {
          let catalog;
          let services;

          beforeEach('setup catalog to be not ready', () => {
            services = webex.internal.services;
            /* eslint-disable-next-line no-underscore-dangle */
            catalog = services._getCatalog();

            catalog.serviceGroups.postauth = [];
          });

          it('should return a rejected promise', () => {
            assert.isUndefined(services.get('wdm'));
            assert.isRejected(devices.canRegister(wait));
          });
        });
      });
    });

    describe('#clear()', () => {
      beforeEach('append a feature', () => {
        devices.features.set({
          developer: [{
            key: 'console',
            type: 'boolean',
            val: 'true',
            value: true,
            mutable: true,
            lastModified: '2015-06-29T20:02:48.033Z'
          }]
        });
      });

      it('should clear all features', () => {
        assert.isAbove(devices.features.developer.length, 0);
        devices.clear();
        assert.lengthOf(devices.features.developer, 0);
      });

      it('should not clear the logger', () => {
        assert.property(devices, 'logger');
        assert.isDefined(devices.logger);
        devices.clear();
        assert.property(devices, 'logger');
        assert.isDefined(devices.logger);
      });
    });

    describe('#checkNetworkReachability()', () => {
      describe('when the reachability check has already been completed', () => {
        beforeEach('set reachability checked to true', () => {
          devices.isReachabilityChecked = true;
        });

        it('should return a resolved promise', () => {
          assert.isFulfilled(devices.checkNetworkReachability());
        });
      });

      describe('when there is no intranet inactivity check url', () => {
        beforeEach('set devices properties', () => {
          devices.intranetInactivityCheckUrl = undefined;
          devices.isReachabilityChecked = false;
        });

        it('should set the in-network property to false',
          () => devices.checkNetworkReachability()
            .then(() => {
              assert.isFalse(devices.isInNetwork);
            }));

        it('should return a resolved promise',
          () => devices.checkNetworkReachability()
            .then(() => assert.isTrue(true, 'resolved the promise')));

        describe('when the device has inactivity enforcement', () => {
          let logoutTimer;

          beforeEach('set device to enforce inactivity timers', () => {
            devices.config.enableInactivityEnforcement = true;
            logoutTimer = devices.logoutTimer;
            devices.intranetInactivityCheckUrl = undefined;
          });

          it('should not reset the logout timer',
            () => devices.checkNetworkReachability()
              .then(() => assert.equal(devices.logoutTimer, logoutTimer)));
        });
      });

      describe('when the rechability check is performable', () => {
        beforeEach('setup for reachability check', () => {
          // Due to property overriding, `isReachabilityChecked` must be set
          // within each `it` statement.
          devices.isInNetwork = false;
        });

        describe('when the network is reachabable', () => {
          beforeEach('set inactivity check url and stubs', () => {
            devices.intranetInactivityCheckUrl =
              'https://myspark.cisco.com/spark_session_check.json';

            devices.resetLogoutTimer = sinon.spy();

            devices.request = sinon.stub().resolves({});
          });

          it('should call \'resetLogoutTimer()\'', () => {
            devices.isReachabilityChecked = false;

            return devices.checkNetworkReachability()
              .then(() => assert.called(devices.resetLogoutTimer));
          });

          it('should set the reachability check to true', () => {
            devices.isReachabilityChecked = false;

            return devices.checkNetworkReachability()
              .then(() => assert.isTrue(devices.isReachabilityChecked));
          });

          it('should set the in-network property to true', () => {
            devices.isReachabilityChecked = false;

            assert.isFalse(devices.isInNetwork);

            return devices.checkNetworkReachability()
              .then(() => assert.isTrue(devices.isInNetwork));
          });

          it('should return a resolved promise',
            () => assert.isFulfilled(devices.checkNetworkReachability()));
        });

        describe('when the network is not reachable', () => {
          beforeEach('set an invalid inactivity check url', () => {
            devices.intranetInactivityCheckUrl =
              'https://myspark.cisco.com/bad-spark_session_check.json';
          });

          it('should set the reachability check to true', () => {
            devices.isReachabilityChecked = false;

            return devices.checkNetworkReachability()
              .then(() => assert.isTrue(devices.isReachabilityChecked));
          });

          it('should set the in-network property to false',
            () => devices.checkNetworkReachability()
              .then(() => assert.isFalse(devices.isInNetwork)));

          it('should return a resolved promise',
            () => assert.isFulfilled(devices.checkNetworkReachability()));
        });
      });
    });

    describe('#getWebSocketUrl()', () => {});

    describe('#meetingStarted()', () => {
      let spy;

      beforeEach('setup instance function', () => {
        spy = sinon.spy();
      });

      it('should trigger a \'meeting started\' event', () => {
        webex.on('meeting started', spy);
        devices.meetingStarted();
        assert.called(spy);
      });
    });

    describe('#meetingEnded()', () => {
      let spy;

      beforeEach('setup instance function', () => {
        spy = sinon.spy();
      });

      it('should trigger a \'meeting ended\' event', () => {
        webex.on('meeting ended', spy);
        devices.meetingEnded();
        assert.called(spy);
      });
    });

    describe('#processRegistrationSuccess()', () => {
      let customResponse;
      let spy;

      beforeEach('setup parameters', () => {
        customResponse = {
          body: {
            exampleKey: 'exampleValue'
          }
        };

        spy = sinon.spy();
      });

      it('should set the device properties to the response values', () => {
        devices.processRegistrationSuccess(customResponse);
        assert.equal(devices.exampleKey, customResponse.body.exampleKey);
      });

      it(`should trigger '${DEVICES_EVENT_REGISTRATION_SUCCESS}'`, () => {
        devices.on(DEVICES_EVENT_REGISTRATION_SUCCESS, spy);
        devices.processRegistrationSuccess(customResponse);
        assert.called(spy);
      });

      describe('when the device is ephemeral', () => {
        beforeEach('set the device to ephemeral', () => {
          devices.config.ephemeral = true;
        });

        it('should create a refresh timer', () => {
          const {refreshTimer} = devices;

          devices.processRegistrationSuccess(customResponse);
          assert.notEqual(devices.refreshTimer, refreshTimer);
          assert.isDefined(devices.refreshTimer);
        });
      });
    });

    describe('#refresh()', () => {});
    describe('#register()', () => {});

    describe('#resetLogoutTimer()', () => {
      describe('when inactivty enforcement is enabled', () => {
        beforeEach('set inactity enforcement and reachability checked', () => {
          devices.config.enableInactivityEnforcement = true;
          devices.isReachabilityChecked = true;
        });

        describe('when the user is in a meeting', () => {
          beforeEach('set user to be in a meeting', () => {
            devices.isInMeeting = true;
          });

          it('should not set the logout timer', () => {
            devices.resetLogoutTimer();

            assert.isUndefined(devices.logoutTimer);
          });
        });

        describe('when the user is not in a meeting', () => {
          beforeEach('setup the \'setLogoutTimer()\' spy', () => {
            devices.setLogoutTimer = sinon.stub();
          });

          describe('when the user is in network', () => {
            beforeEach('set user to be in network', () => {
              devices.isInNetwork = true;
            });

            it('should set the logout timer to the in-network duration', () => {
              devices.resetLogoutTimer();

              assert.calledWith(
                devices.setLogoutTimer,
                devices.intranetInactivityCheckUrl
              );
            });
          });

          describe('when the user is not in network', () => {
            beforeEach('set the user to not be in network', () => {
              devices.isInNetwork = false;
            });

            it('should set the logout timer to the intranet duration', () => {
              devices.resetLogoutTimer();

              assert.calledWith(
                devices.setLogoutTimer,
                devices.intranetInactivityDuration
              );
            });
          });
        });
      });
    });

    describe('#unregister()', () => {});
    describe('#waitForRegistration()', () => {});
  });
});
